
## Curve25519

The elliptic curve cryptography implementation is the most technically involved
part of this project. [@Curve25519] gives explicit formulas for the elliptic
curve arithmetic in terms of operations on integers modulo $2^{255} - 19$. Our
implementation of the `curve25519` module follows the figure presented in the
appendix of that paper and makes use of the properties of our modular arithmetic
modules to provide better performance. To save area, the circuit has only one
copy of the modular multiplication unit and one add/subtract unit; these are
used in sequence to compute the elliptic curve operation. Furthermore, as the
latency of our modular multiplication unit is twice as high as the latency of
the addition/subtraction unit, but the throughput is the same, we did our best
to keep the multiplication pipeline active at all times. This results in using 7
255-bit registers to store the intermediate values, in addition to the internal
registers of the modular arithmetic units. All in all, our implementation
requires less than 70000 cycles to perform an elliptic curve operation (public
key generation or shared key generation). Our implementation is a trade-off
between speed, circuit area, and complexity. We believe that more careful
pipeline management could offer slightly better speeds for any area, storing the
intermediate values of the elliptic curve operations in block RAM instead of
registers would allow for a smaller area at the expense of speed, and
implementing a dedicated modular division (inversion) unit would allow for
significantly better performance at even larger expense of area.

### Modular multiplication

We took advantage of the pseudo-Mersenne structure of the modulus
($p=2^{255}-19) and the availability of 18-by-18-bit multipliers to create
implement an efficient modular multiplication unit. The overall strategy goes as
follows:

1. Interpret each 255-bit input as 15 17-bit digits. While it would have been
   possible to use 18-bit digits, choosing 17 greatly simplifies the implementation
   because 255 bits can be evenly divided into 17-bit digits but not into 18-bit
   digits.
2. Perform an algorithm similar to schoolbook multiplication, where
	- During each clock cycle, one row of partial products is computed
	- Each partial product that would eventually overflow the 255-bit result
because of its position is omitted from the calculation.
	- However, the overflowing partial product is not discarded. As the modulus
	  is *not* a power of two, correct for the difference between two's
      complement integer overflow and addition mod $p$ by adding 19 times the number
      of times the overflow wrapped around to the result. Because there must be an
      empty low order partial product slot for each partial product that is statically
      known to overflow, no addition needs to be performed: the just system places 19
      times the overflowing partial product to the correct slot.
3. Cumulatively add up the columns of partial products, but do not handle
   carries between them. The sum of each column has an upper bound of 42 bits
   because it is a sum of 17 products of two 17-bit numbers times 19.
4. Handle carries from the two most significant columns, adding the number of
   overflows times 19 to the result as before.
5. Handle all remaining carries starting from the least significant column and
   moving towards towards the most significant column. The result will be
   between $0$ and $2p$.
6. If the result overflows (has a carry of 1), subtract $p$ from it. This is *not* implemented as a
separate step. Instead, there are two copies of steps 4 and 5, one of which
works as described and the other subtracts the appropriate digit of $p$ while
handling each carry. The correct output is selected amongst the two branches
using the carry bit.

The breakdown of time usage is roughly as follows: step 2 takes 17 cycles, step
4 takes 1 cycle, and step 5 takes 17 cycles. As the FPGA provides fast
17-by-17-bit multipliers in dedicated silicon, the main area usage is due to the
the accumulator registers and the 42-bit adders used for adding up columns and
propagating carries.

### Addition and Subtraction

Addition and subtraction also operate on 15 17-bit digits.
